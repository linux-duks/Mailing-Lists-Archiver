import re
import logging
import email.generator
import email.header
import email.parser
import email.policy
import email.quoprimime
import email.utils
from email.message import EmailMessage
from typing import (
    Optional,
    Tuple,
    Set,
    List,
    BinaryIO,
    Union,
    Sequence,
    Literal,
    Iterator,
    Dict,
    TypeVar,
    overload,
    Generator,
    Any,
)


logger = logging.getLogger("email_reader")


def decode_mail(email_raw) -> str:
    # TODO: test
    # policy = email.policy.smtp
    policy = email.policy.default
    msg = email.parser.BytesParser(policy=policy).parsebytes(email_raw)
    return msg


# -> List[Tuple(str, str)]
#


def get_headers(msg: EmailMessage) -> Dict[str, str | list[str]]:
    headers = {}
    for key, item in msg.items():
        if key in headers:
            existing = headers.get(key)
            # if field if list, append new value
            if isinstance(existing, list):
                headers[key].append(item)
            else:
                headers[key] = [existing, item]
        else:
            headers[key] = item
    return headers


def get_body(msg: EmailMessage) -> str:
    try:
        charset = msg.get_content_charset()

        body = msg.get_payload(decode=True)
        text = ""
        if body is not None:
            text = body.decode(charset or "utf-8", errors="replace")
        else:
            return ""
        return text
    except Exception as e:
        logger.error("failed loading body", e)
        return ""


#
# def get_body_parts(
#     body: str,
# ) -> Tuple[List[LoreTrailer], str, List[LoreTrailer], str, str]:
#     # remove any starting/trailing blank lines
#     body = body.replace("\r", "")
#     body = body.strip("\n")
#     # Extra git-relevant headers, like From:, Subject:, Date:, etc
#     githeaders = list()
#     # commit message
#     message = ""
#     # everything below the ---
#     basement = ""
#     # conformant signature --\s\n
#     signature = ""
#     sparts = body.rsplit("\n-- \n", 1)
#     if len(sparts) > 1:
#         signature = sparts[1]
#         body = sparts[0]
#
#     parts = re.split("^---\n", body, maxsplit=1, flags=re.M)
#     if len(parts) == 2:
#         basement = parts[1]
#     elif body.find("\ndiff ") >= 0:
#         parts = body.split("\ndiff ", 1)
#         if len(parts) == 2:
#             parts[1] = "diff " + parts[1]
#         basement = parts[1]
#     elif body.find("\n--- a/") >= 0:
#         # patches generated by some really peculiar tools
#         parts = body.split("\n--- a/", 1)
#         if len(parts) == 2:
#             parts[1] = "--- a/" + parts[1]
#         basement = parts[1]
#
#     mbody = parts[0].strip("\n")
#
#     # Split into paragraphs
#     bpara = mbody.split("\n\n")
#
#     # Is every line of the first part in a header format?
#     mparts = list()
#     h, o = find_trailers(bpara[0])
#     if len(o):
#         # Not everything was a header, so we don't treat it as headers
#         mparts.append(bpara[0])
#     else:
#         githeaders = h
#
#     # Any lines of the last part match the header format?
#     trailers, nlines = find_trailers(bpara[-1])
#
#     if len(bpara) == 1:
#         if githeaders == trailers:
#             # This is a message that consists of just trailers?
#             githeaders = list()
#         if nlines:
#             message = "\n".join(nlines)
#         return githeaders, message, trailers, basement, signature
#
#     # Add all parts between first and last to mparts
#     if len(bpara) > 2:
#         mparts += bpara[1:-1]
#
#     if len(nlines):
#         # Add them as the last part
#         mparts.append("\n".join(nlines))
#
#     message = "\n\n".join(mparts)
#
#     return githeaders, message, trailers, basement, signature
#
#
# def find_trailers(
#     body: str, followup: bool = False
# ) -> Tuple[List[LoreTrailer], List[str]]:
#     ignores = {"phone", "email", "e-mail", "prerequisite-message-id"}
#     headers = {"subject", "date", "from"}
#     links = {"link", "buglink", "closes"}
#     nonperson = links | {
#         "fixes",
#         "subject",
#         "date",
#         "obsoleted-by",
#         "change-id",
#         "base-commit",
#     }
#     # Ignore everything below standard email signature marker
#     body = body.split("\n-- \n", 1)[0].strip() + "\n"
#     # Fix some more common copypasta trailer wrapping
#     # Fixes: abcd0123 (foo bar
#     # baz quux)
#     body = re.sub(
#         r"^(\S+:\s+[\da-f]+\s+\([^)]+)\n([^\n]+\))", r"\1 \2", body, flags=re.M
#     )
#     # Signed-off-by: Long Name
#     # <email.here@example.com>
#     body = re.sub(r"^(\S+:\s+[^<]+)\n(<[^>]+>)$", r"\1 \2", body, flags=re.M)
#     # Signed-off-by: Foo foo <foo@foo.com>
#     # [for the thing that the thing is too long the thing that is
#     # thing but thing]
#     # (too false-positivey, commented out)
#     # body = re.sub(r'^(\[[^]]+)\n([^]]+]$)', r'\1 \2', body, flags=re.M)
#     trailers: List[LoreTrailer] = list()
#     others: List[str] = list()
#     was_trailer = False
#     at = 0
#     for line in body.split("\n"):
#         at += 1
#         line = line.strip("\r")
#         matches = re.search(r"^\s*(\w\S+):\s+(\S.*)", line, flags=re.I)
#         if matches:
#             oname, ovalue = list(matches.groups())
#             # We only accept headers if we haven't seen any non-trailer lines
#             lname = oname.lower()
#             if lname in ignores:
#                 logger.debug("Ignoring %d: %s (known non-trailer)", at, line)
#                 continue
#             if len(others) and lname in headers:
#                 logger.debug("Ignoring %d: %s (header after other content)", at, line)
#                 continue
#             if followup:
#                 if not lname.isascii():
#                     logger.debug(
#                         "Ignoring %d: %s (known non-ascii follow-up trailer)", at, lname
#                     )
#                     continue
#                 mperson = re.search(r"\S+@\S+\.\S+", ovalue)
#                 if not mperson and lname not in nonperson:
#                     logger.debug(
#                         "Ignoring %d: %s (not a recognized non-person trailer)",
#                         at,
#                         line,
#                     )
#                     continue
#                 mlink = re.search(r"https?://", ovalue)
#                 if mlink and lname not in links:
#                     logger.debug(
#                         "Ignoring %d: %s (not a recognized link trailer)", at, line
#                     )
#                     continue
#
#             extinfo = None
#             mextinfo = re.search(r"(.*\S+)(\s+#[^#]+)$", ovalue)
#             if mextinfo:
#                 logger.debug("Trailer contains hashtag extinfo: %d: %s", at, line)
#                 # Found extinfo of the hashtag genre
#                 egr = mextinfo.groups()
#                 ovalue = egr[0]
#                 extinfo = egr[1]
#
#             was_trailer = True
#             ltrailer = LoreTrailer(name=oname, value=ovalue, extinfo=extinfo)
#             trailers.append(ltrailer)
#             continue
#         # Is it an extended info line, e.g.:
#         # Signed-off-by: Foo Foo <foo@foo.com>
#         # [for the foo bits]
#         if len(line) > 2 and was_trailer and re.search(r"^\s*\[[^]]+]\s*$", line):
#             trailers[-1].extinfo = line
#             was_trailer = False
#             continue
#         was_trailer = False
#         others.append(line)
#
#     return trailers, others
#
#
#
# class LoreTrailer:
#     type: str
#     name: str
#     lname: str
#     value: str
#     extinfo: Optional[str] = None
#     addr: Optional[Tuple[str, str]] = None
#     # lmsg: Optional["LoreMessage"] = None
#     # Small list of recognized utility trailers
#     _utility: Set[str] = {
#         "fixes",
#         "link",
#         "buglink",
#         "closes",
#         "obsoleted-by",
#         "message-id",
#         "change-id",
#         "base-commit",
#         "based-on",
#     }
#
#     def __init__(
#         self,
#         name: Optional[str] = None,
#         value: Optional[str] = None,
#         extinfo: Optional[str] = None,
#         msg: Optional[EmailMessage] = None,
#     ):
#         self.name = name
#         self.value = value
#         if name.lower() in self._utility or "://" in value:
#             self.type = "utility"
#         elif re.search(r"\S+@\S+\.\S+", value):
#             self.type = "person"
#             if "<mailto:" in value:
#                 # This was inserted by a mail client that back-converted from html mail
#                 # Remove the <mailto:...> part
#                 self.value = re.sub(r"<mailto:[^>]+>", "", value)
#             self.addr = email.utils.parseaddr(self.value)
#             # Normalize the value with parsed data
#             if self.addr[0] or self.addr[1]:
#                 self.value = format_addrs([self.addr], header_safe=False)
#             else:
#                 self.type = "unknown"
#         else:
#             self.type = "unknown"
#         self.lname = self.name.lower()
#         self.extinfo = extinfo
#         self.msg = msg
#
#     def as_string(self, omit_extinfo: bool = False) -> str:
#         ret = f"{self.name}: {self.value}"
#         if not self.extinfo or omit_extinfo:
#             return ret
#         # extinfo can be either be [on the next line], or  # at the end
#         if self.extinfo.lstrip()[0] == "#":
#             ret += self.extinfo
#         else:
#             ret += f"\n{self.extinfo}"
#
#         return ret
#
#     @property
#     def origin(self) -> str:
#         """Return the origin of this trailer, if it has one."""
#         if self.lmsg is None:
#             return "(origin unknown)"
#         return self.lmsg.msgid
#
#     def email_eq(self, cmp_email: str, fuzzy: bool = True) -> bool:
#         if not self.addr:
#             return False
#         our = self.addr[1].lower()
#         their = cmp_email.lower()
#         if our == their:
#             return True
#         if not fuzzy:
#             return False
#
#         if "@" not in our or "@" not in their:
#             return False
#
#         # Strip extended local parts often added by people, e.g.:
#         # comparing foo@example.com and foo+kernel@example.com should match
#         our = re.sub(r"\+[^@]+@", "@", our)
#         their = re.sub(r"\+[^@]+@", "@", their)
#         if our == their:
#             return True
#
#         # See if domain part of one of the addresses is a subset of the other one,
#         # which should match cases like foo@linux.intel.com and foo@intel.com
#         olocal, odomain = our.split("@", maxsplit=1)
#         tlocal, tdomain = their.split("@", maxsplit=1)
#         if olocal != tlocal:
#             return False
#
#         if abs(odomain.count(".") - tdomain.count(".")) == 1 and (
#             odomain.endswith(f".{tdomain}") or tdomain.endswith(f".{odomain}")
#         ):
#             return True
#
#         return False
#
#     def __eq__(self, other: object) -> bool:
#         if not isinstance(other, LoreTrailer):
#             return NotImplemented
#         # We never compare extinfo, we just tack it if we find a match
#         return self.lname == other.lname and self.value.lower() == other.value.lower()
#
#     def __hash__(self) -> int:
#         return hash(f"{self.lname}: {self.value}")
#
#     def __repr__(self) -> str:
#         out = list()
#         out.append("  type: %s" % self.type)
#         out.append("  name: %s" % self.name)
#         out.append("  value: %s" % self.value)
#         out.append("  extinfo: %s" % self.extinfo)
#         if self.lmsg:
#             out.append("  lmsg.subject: %s" % self.lmsg.subject)
#             out.append("  lmsg.msgid: %s" % self.lmsg.msgid)
#
#         return "\n".join(out)
#

# # Presence of these characters requires quoting of the name in the header
# # adapted from email._parseaddr
# qspecials = re.compile(r"[()<>@,:;.\"\[\]]")


# def format_addrs(
#     pairs: List[Tuple[str, str]], clean: bool = True, header_safe: bool = True
# ) -> str:
#     addrs = list()
#     for pair in pairs:
#         if not pair[0] or pair[0] == pair[1]:
#             addrs.append(pair[1])
#             continue
#         if clean:
#             # Remove any quoted-printable header junk from the name
#             pair = (LoreMessage.clean_header(pair[0]), pair[1])
#         if not header_safe:
#             addrs.append(f"{pair[0]} <{pair[1]}>")
#             continue
#         # Work around https://github.com/python/cpython/issues/100900
#         if (
#             not pair[0].startswith("=?")
#             and not pair[0].startswith('"')
#             and qspecials.search(pair[0])
#         ):
#             quoted = email.utils.quote(pair[0])
#             addrs.append(f'"{quoted}" <{pair[1]}>')
#             continue
#         addrs.append(email.utils.formataddr(pair))
#     return ", ".join(addrs)
#
#
# def clean_header(hdrval: Optional[str]) -> str:
#     if hdrval is None:
#         return ""
#
#     if hdrval.find("=?") >= 0:
#         # Do we have any email addresses in there?
#         if re.search(r"<\S+@\S+>", hdrval, flags=re.I | re.M):
#             newaddrs = list()
#             for addr in email.utils.getaddresses([hdrval]):
#                 if addr[0].find("=?") >= 0:
#                     # Nothing wrong with nested calls, right?
#                     addr = (clean_header(addr[0]), addr[1])
#                 # Work around https://github.com/python/cpython/issues/100900
#                 if re.search(r"[^\w\s]", addr[0]):
#                     newaddrs.append(f'"{addr[0]}" <{addr[1]}>')
#                 else:
#                     newaddrs.append(email.utils.formataddr(addr))
#             return ", ".join(newaddrs)
#
#         decoded = ""
#         for hstr, hcs in email.header.decode_header(hdrval):
#             if hcs is None:
#                 hcs = "utf-8"
#             try:
#                 decoded += hstr.decode(hcs, errors="replace")
#             except LookupError:
#                 # Try as utf-8
#                 decoded += hstr.decode("utf-8", errors="replace")
#             except (UnicodeDecodeError, AttributeError):
#                 decoded += hstr
#     else:
#         decoded = hdrval
#
#     new_hdrval = re.sub(r"\n?\s+", " ", decoded)
#     return new_hdrval.strip()
